<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="Publish.jl" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="" />
    <title>DLPipelines.jl</title>
    <link rel="stylesheet" href="..&#x2F;normalize.css" />
    <link rel="stylesheet" href="..&#x2F;tabulator_simple.min.css" />
    <link rel="stylesheet" href="..&#x2F;lorenzo.css" />
    <script src="..&#x2F;versions.js"></script>
    <script src="..&#x2F;lunr.js"></script>
    <script src="..&#x2F;highlight.min.js"></script>
    <script src="..&#x2F;tabulator.min.js"></script>
    <script src="..&#x2F;julia.min.js"></script>
    <script src="..&#x2F;julia-repl.min.js"></script>
    <script src="..&#x2F;publish.js"></script>
    
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Lora:wght@700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Lora:wght@500&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Lora:ital@1&family=Source+Sans+Pro:wght@700&display=swap" rel="stylesheet">
    <!-- 
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
        -->

</head>
<body>
    <main id="page">
        <div class="menu">
            <div id="projectname">DLPipelines.jl</div>
            <input id="search-input" placeholder="Search">
            <select id="version-selector"></select>
            <svg id="menu-toggler" title="Contents" onclick="toggleIndexPage();" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor" /><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor" /><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor" /></svg>
        </div>
        <div id="toc"><ul>
<li><a href="../README.html">Readme</a></li>
<li><a href="../docs/introduction.html">Introduction</a></li>
</ul>
<h2 id="interfacesdocsinterfacesoverviewmd"><a href="../#interfacesdocsinterfacesoverviewmd" class="anchor"></a><a href="../docs/interfaces/overview.html">Interfaces</a></h2>
<ul>
<li><a href="../docs/interfaces/core.html">Core interface</a></li>
</ul>
<h2 id="functionalitydocsfunctionalitymd"><a href="../#functionalitydocsfunctionalitymd" class="anchor"></a><a href="../docs/functionality.html">Functionality</a></h2>
</div>
        <article><h1 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h1>
<h2 id="terminology"><a href="#terminology" class="anchor"></a>Terminology</h2>
<p>In supervised deep learning, we’re usually trying to solve a problem by finding a mapping from some input to some target. Let’s call this a <em>task</em>. Consider the following tasks:</p>
<table><thead><tr><th align="left">Task</th><th align="left">Input</th><th align="left">Target</th></tr></thead><tbody><tr><td align="left">Image classification</td><td align="left">Image</td><td align="left">Category</td></tr><tr><td align="left">Semantic segmentation</td><td align="left">Image</td><td align="left">Category per pixel</td></tr><tr><td align="left">Object detection</td><td align="left">Image</td><td align="left">Bounding boxes</td></tr><tr><td align="left">Text completion</td><td align="left">Text</td><td align="left">Next character</td></tr></tbody></table>
<p>There are usually multiple ways to go about solving a task. We call a <em>method</em> a concrete approach to a task that has a learnable part (the model) but also defines how</p>
<ul>
<li>inputs and targets are <em>encoded</em> into a form that can be fed to and output by the model</li>
<li>model outputs are <em>decoded</em> to obtain target predictions; and</li>
</ul>
<p>As an example method, consider the commmon way of approaching the task of image classification:</p>
<ul>
<li>images are encoded into normalized 3D-Arrays of <code>Float32</code>s and categories into one-hot vectors</li>
<li>the predicted probability distributions can be decoded into a category by finding the index of the highest score; and</li>
<li>the model takes in batches of encoded inputs and output batches of encoded targets</li>
</ul>
<p>An additional complication comes from the fact that the encoding and decoding step may differ based on the context. For example, during training we often want to augment the inputs which would be detrimental to performance during inference.</p>
<h2 id="in-code"><a href="#in-code" class="anchor"></a>In code</h2>
<p>Let’s give those concepts variable names and generic types so we can refer to them more easily.</p>
<table><thead><tr><th align="right">Concept</th><th align="left">Abstract code</th><th align="left">Image classification</th></tr></thead><tbody><tr><td align="right">Task</td><td align="left"><code>Task</code></td><td align="left"><code>ImageClassificationTask &lt;: Task</code></td></tr><tr><td align="right">Method</td><td align="left"><code>Method{Task}</code></td><td align="left"><code>ImageClassification &lt;: Method{ImageClassificationTask}</code></td></tr><tr><td align="right">Input</td><td align="left"><code>input::I</code></td><td align="left"><code>image::AbstractMatrix{&lt;:Colorant}</code></td></tr><tr><td align="right">Target</td><td align="left"><code>target::T</code></td><td align="left"><code>category::String</code></td></tr><tr><td align="right">Encoded input</td><td align="left"><code>x::X</code></td><td align="left"><code>x::AbstractArray{Float32, 3}</code></td></tr><tr><td align="right">Encoded target</td><td align="left"><code>y::Y</code></td><td align="left"><code>y::Vector{Float32}</code></td></tr><tr><td align="right">Model output</td><td align="left"><code>ŷ::Ŷ</code></td><td align="left"><code>y::Vector{Float32}</code></td></tr></tbody></table>
<p>So a <code>Task</code> is an abstract type representing a mapping from some input type <code>I</code> to target type <code>T</code>. A <code>Method{T}</code> implements the task <code>T</code> by using encoded representations <code>X</code> and <code>Y</code>. For example, the <code>ImageClassificationTask</code> task represents a mapping from an image to a category. The concrete <a href="../docstrings/DLPipelines.LearningMethod.html"><code>LearningMethod</code></a> <code>ImageClassification</code> implements that task using the encoded representations defined in the table above.</p>
<p>The most important type is <a href="../docstrings/DLPipelines.LearningMethod.html"><code>LearningMethod</code></a> which represents a method for a <a href="../docstrings/DLPipelines.LearningTask.html"><code>LearningTask</code></a>. All interface functions will dispatch on <code>LearningMethod</code>. It should be a concrete <code>struct</code> containing necessary configuration.</p>
<h2 id="core-pipelines"><a href="#core-pipelines" class="anchor"></a>Core pipelines</h2>
<p class="marginnote">We neglect batching here, as it doesn’t change the semantics of the data pipeline, just the practical implementation.</p>
<p>To give a motivation for the interface, consider the two most important pipelines in a deep learning application: training and inference.</p>
<p>During inference, we have an input and obtain a target prediction. Writing this with types gives us:</p>
<pre><code class="language-text">     encode       model       decode
::I -------&gt; ::X ------&gt; ::Ŷ -------&gt; ::T
</code></pre>
<p>When training, we first encode both input and target, including any augmentation. We then feed the encoded input to the model and compare its output with the true encoded target.</p>
<pre><code class="language-text">          encode            lossfn(model(X), Y)
::(I, 0) -------&gt; ::(X, Y) --------------------&gt; loss
</code></pre>
<p>From those two pipelines, we can extract the following transformations:</p>
<ul>
<li><code>I -&gt; X</code> encoding input</li>
<li><code>Ŷ -&gt; T</code> decoding model output</li>
<li><code>(I, T) -&gt; (X, Y)</code> encoding input and target</li>
</ul>
<p>These make up the <a href="interfaces/core.html">core interface</a>.</p>
</article>
        <div id="page-navigation">
            <a id="previous-page" title="Previous" href="..&#x2F;README.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.2426 6.34317L14.8284 4.92896L7.75739 12L14.8285 19.0711L16.2427 17.6569L10.5858 12L16.2426 6.34317Z" fill="currentColor" /></svg></a>
            <a id="next-page" title="Next" href="interfaces&#x2F;overview.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5858 6.34317L12 4.92896L19.0711 12L12 19.0711L10.5858 17.6569L16.2427 12L10.5858 6.34317Z" fill="currentColor" /></svg></a>
        </div>
        <footer>
            Built with <a target="_blank" href="https://github.com/MichaelHatherly/Publish.jl">Publish.jl</a> and the <a target="_blank" href="https://julialang.org">Julia Language</a>.
        </footer>
    </main>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
